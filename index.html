<!DOCTYPE html>
<html>
<head>
    <title>AT Transit Realtime</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta content="script-src 'self' https://unpkg.com https://cdnjs.cloudflare.com https://www.googletagmanager.com;">
    <link rel="shortcut icon" type="image/x-icon" href="docs/images/favicon.ico" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.5.1/dist/leaflet.css"
        integrity="sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ=="
        crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.5.1/dist/leaflet.js"
        integrity="sha512-GffPMF3RvMeYyc1LWMHtK8EbPv0iNZ8/oTtHPx9/cc2ILxQ+u905qIwdpULaqDkyBKgOaB57QTMg7ztg8Jm2Og=="
        crossorigin=""></script>
    <script src="https://unpkg.com/leaflet-providers@1.3.0/leaflet-providers.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"
        integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/spin.js/2.3.2/spin.min.js"></script>
    <script src="https://unpkg.com/leaflet-spin@1.1.0/leaflet.spin.min.js"></script>
    <script src="https://unpkg.com/leaflet-search@2.9.8/dist/leaflet-search.src.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.0.3/chroma.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-search@2.9.8/src/leaflet-search.css" />
    <style>
        body, html { width: 100%; height: 100%; margin: 0; padding: 0; }
        #map { position: absolute; width: 100%; height: 100%; left: 0; top: 0; }
        #title {
            position: absolute;
            top: 10px;
            left: 0; right: 0; margin: auto;
            z-index: 1000; width: 500px;
            text-align: center; color: white; border-radius: 5px; padding: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            font-size: 1rem; font-family: Arial, Helvetica, sans-serif;
            text-shadow: 2px 2px #000000; font-weight: normal;
        }
        .info {
            background-color: white; padding: 15px; color: black;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2); border-radius: 5px;
        }
        .pattern-toggle {
            margin-top: 8px;
        }
    </style>
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-77710107-12"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-77710107-12');
    </script>
</head>
<body>
    <h1 id="title">Welcome to the Auckland Transport Transit Realtime Map!</h1>
    <div id="map"></div>
    <script>
        var map = L.map('map', {
            center: [-36.8862, 174.7651],
            zoom: 12,
            worldCopyJump: true
        });

        var positron = L.tileLayer.provider('CartoDB.Positron').addTo(map);

        var baseMaps = {
            "OSM": L.tileLayer.provider("OpenStreetMap.Mapnik"),
            "OSM Grayscale": L.tileLayer.provider("OpenStreetMap.BlackAndWhite"),
            "CartoDB Positron": positron,
            "CartoDB Dark Matter": L.tileLayer.provider("CartoDB.DarkMatter"),
            "ESRI WorldImagery": L.tileLayer.provider("Esri.WorldImagery"),
            "Google Hybrid": L.tileLayer('http://{s}.google.com/vt/lyrs=s,h&x={x}&y={y}&z={z}', {
                maxZoom: 20,
                subdomains: ['mt0', 'mt1', 'mt2', 'mt3']
            }),
            "Wikimedia": L.tileLayer.provider("Wikimedia")
        };

        map.attributionControl.addAttribution("© <a href='https://dev-portal.at.govt.nz/'>AT</a>");

        var layers = {
            2: L.layerGroup().addTo(map),
            3: L.layerGroup().addTo(map),
            4: L.layerGroup().addTo(map),
            null: L.layerGroup().addTo(map)
        };

        var search = L.control.search({
            layer: L.layerGroup([layers[2], layers[3], layers[4], layers[null]]),
            initial: false,
            propertyName: 'desc'
        });
        map.addControl(search);

        // Use event delegation for .search-input which is dynamically inserted by Leaflet Search
        $(document).on("keyup", ".search-input", function () {
            var searchVal = this.value.toLowerCase();
            for (var i in markers) {
                if (!markers.hasOwnProperty(i)) continue;
                var marker = markers[i];
                if (!searchVal || (marker.options.desc && marker.options.desc.toLowerCase().includes(searchVal))) {
                    marker.setStyle({ opacity: 1, fillOpacity: .2 });
                } else {
                    marker.setStyle({ opacity: 0, fillOpacity: 0 });
                }
            }
        });

        var overlayMaps = {
            "AT Buses": layers[3],
            "AT Trains": layers[2],
            "AT Ferries": layers[4],
            "Out of Service": layers[null]
        };

        L.control.layers(baseMaps, overlayMaps).addTo(map);

        var legend = L.control({ position: 'bottomright' });
        legend.onAdd = function (map) {
            var div = L.DomUtil.create('div', 'info legend');
            div.innerHTML = 'Colour by: <select id="colourscheme"><option>Route</option><option>Occupancy</option><option>Speed</option></select><div id="status"></div>';
            return div;
        };
        legend.addTo(map);

        $(document).on("change", "#colourscheme", function () {
            window.colourscheme = this.value;
            location.hash = this.value;
            for (var i in markers) {
                if (!markers.hasOwnProperty(i)) continue;
                updateMarkerColour(markers[i]);
            }
        });

        window.colourscheme = "Route";
        if (location.hash) {
            window.colourscheme = location.hash.slice(1);
            $("#colourscheme").val(window.colourscheme);
        }

        function stringToColour(str) {
            var hash = 0;
            for (var i = 0; i < str.length; i++) {
                hash = str.charCodeAt(i) + ((hash << 5) - hash);
            }
            var colour = '#';
            for (var i = 0; i < 3; i++) {
                var value = (hash >> (i * 8)) & 0xFF;
                colour += ('00' + value.toString(16)).substr(-2);
            }
            return colour;
        }

        function updateMarkerColour(marker) {
            var color = "black";
            if (window.colourscheme == "Route") {
                if (marker.route_type == 4) {
                    color = "blue";
                } else if (marker.route_long_name) {
                    color = stringToColour(marker.route_long_name);
                }
            } else if (window.colourscheme == "Occupancy" && marker.occupancy_status !== undefined) {
                color = occupancyColors[marker.occupancy_status];
            } else if (window.colourscheme == "Speed") {
                color = speedColors(marker.speed);
            }
            marker.setStyle({ color: color });
        }

        var markers = {};
        var occupancy = ["empty", "many seats available", "few seats available", "standing room only", "limited standing room", "full", "not accepting passengers"];
        var occupancyColors = ["#4575b4", "#91bfdb", "#e0f3f8", "#fee090", "#fc8d59", "#d73027", "black"];
        var speedColors = chroma.scale([chroma.hsv(270, 1, 1), chroma.hsv(180, 1, 1), chroma.hsv(90, 1, 1), chroma.hsv(0, 1, 1)]).mode("hsv").domain([0, 100]);

        var hasLoaded = false;
        var routes = {};

        // Helper: safe id for building per-marker DOM ids inside tooltip
        function safeId(input) {
            if (input === null || input === undefined) return "id";
            return String(input).replace(/[^a-zA-Z0-9_\-]/g, "_");
        }

        // Display helper text for bike_allowed / bikes_allowed
        function bikeText(val) {
            // GTFS: 0 = unknown, 1 = allowed, 2 = not allowed
            if (val === null || val === undefined) return "Unknown";
            var n = parseInt(val, 10);
            if (isNaN(n)) return String(val);
            if (n === 1) return "Allowed";
            if (n === 2) return "Not allowed";
            return "Unknown";
        }

        // Display helper for wheelchair/accessibility
        function accessibilityText(val) {
            // GTFS: 0 = unknown, 1 = accessible, 2 = not accessible
            if (val === null || val === undefined) return "Unknown";
            var n = parseInt(val, 10);
            if (isNaN(n)) return String(val);
            if (n === 1) return "Accessible";
            if (n === 2) return "Not accessible";
            return "Unknown";
        }

        // === Route pattern (ArcGIS) support ===
        // We'll fetch bus-route as GeoJSON and build lookup maps to show patterns for GTFS routes.
        var routePatternsGeo = null;              // full GeoJSON
        var routePatternIndex = {};               // normalizedKey -> array of features
        var routePatternNumbersIndex = {};        // normalizedKey -> array of numeric pattern identifiers (strings)
        var patternLayerGroup = L.layerGroup().addTo(map);
        var showPatternOnClick = true;            // toggle behavior

        function normalizeKey(s) {
            if (s === null || s === undefined) return "";
            return String(s).toLowerCase().trim();
        }

        // Try to match GTFS route id to ArcGIS feature. GTFS route '101-202' -> try exact, then prefix '101'
        function candidateKeysForGtfsRoute(gtfsRouteId) {
            if (!gtfsRouteId) return [];
            var keys = [];
            var raw = normalizeKey(gtfsRouteId);
            keys.push(raw);
            // split on non-alphanumeric to get base number (e.g., "101-202" -> "101")
            var first = raw.split(/[^0-9a-z]+/)[0];
            if (first && keys.indexOf(first) === -1) keys.push(first);
            return keys;
        }

        // Add a button to toggle showing route patterns when clicking markers
        var patternToggleControl = L.control({ position: 'topright' });
        patternToggleControl.onAdd = function () {
            var div = L.DomUtil.create('div', 'info');
            div.innerHTML = '<div class="pattern-toggle"><label><input type="checkbox" id="togglePatterns" checked> Show route pattern on vehicle click</label></div>';
            return div;
        };
        patternToggleControl.addTo(map);
        $(document).on('change', '#togglePatterns', function () {
            showPatternOnClick = !!this.checked;
            if (!showPatternOnClick) patternLayerGroup.clearLayers();
        });

        // Try a couple of common GeoJSON endpoints for the ArcGIS open dataset
        function fetchRoutePatterns() {
            // First attempt: standard ArcGIS Open Data + .geojson suffix
            var urls = [
                'https://data-atgis.opendata.arcgis.com/datasets/ATgis::bus-route.geojson',
                // fallback via ArcGIS REST query returning GeoJSON — replace the service url if you have the canonical one
                'https://services.arcgis.com/ZN3Gq8hGnsb8aD0T/ArcGIS/rest/services/bus_route/FeatureServer/0/query?where=1%3D1&outFields=*&f=geojson'
            ];
            // attempt sequentially until one succeeds
            (function tryNext(i) {
                if (i >= urls.length) {
                    console.warn("Could not fetch route patterns from known endpoints.");
                    return;
                }
                var url = urls[i];
                fetch(url)
                    .then(r => {
                        if (!r.ok) throw new Error('HTTP ' + r.status);
                        return r.json();
                    })
                    .then(geojson => {
                        if (!geojson || !geojson.features) throw new Error("Not GeoJSON");
                        routePatternsGeo = geojson;
                        indexRoutePatterns(geojson);
                        console.log("Loaded route pattern GeoJSON from", url);
                    })
                    .catch(err => {
                        console.warn("Failed to fetch patterns from", url, err);
                        tryNext(i + 1);
                    });
            })(0);
        }

        // Extract numeric pattern identifiers (digits) from a feature properties object.
        // Returns an array of string numbers (unique).
        function extractPatternNumbersFromProps(p) {
            if (!p) return [];
            var nums = [];
            Object.keys(p).forEach(function (key) {
                var val = p[key];
                if (val === null || val === undefined) return;
                // convert to string and find numeric groups (1-6 digits)
                var s = String(val);
                // common property names that are likely a pattern id (prefer these)
                var lname = key.toLowerCase();
                if (lname.includes('pattern') || lname.includes('patno') || lname.includes('pat_id') || lname.includes('rtno') || lname.includes('rtno') || lname.includes('route_no') || lname.includes('rteno') || lname.includes('routeid') || lname.includes('route_no')) {
                    var m = s.match(/\d{1,6}/g);
                    if (m) nums = nums.concat(m);
                } else {
                    // fallback: still look for numeric tokens in any string value
                    var m2 = s.match(/\d{2,6}/g); // require at least 2 digits to reduce false positives
                    if (m2) nums = nums.concat(m2);
                }
            });
            // unique and return
            nums = nums.map(n => String(n));
            return nums.filter((v, idx, arr) => arr.indexOf(v) === idx);
        }

        function extractPatternNameFromProps(p) {
            if (!p) return null;
            // common property names that may contain a human-friendly pattern name
            var candidates = [
                p.pattern_name, p.pattern, p.PATTERN, p.Pattern, p.name, p.NAME,
                p.route_pattern, p.RoutePattern, p.DESC, p.DESCRIPTION, p.Descriptn,
                p.RouteNo, p.ROUTE_NO, p.route_no, p.Route, p.RouteName, p.ROUTE
            ];
            for (var i = 0; i < candidates.length; i++) {
                var v = candidates[i];
                if (v === undefined || v === null) continue;
                var s = String(v).trim();
                if (s.length > 0 && s.toLowerCase() !== 'null') return s;
            }
            // fallback: use any property that looks useful (short alphanumeric)
            for (var key in p) {
                if (!p.hasOwnProperty(key)) continue;
                var val = p[key];
                if (!val) continue;
                var s = String(val).trim();
                if (s.length > 0 && s.length <= 30) return s;
            }
            return null;
        }

        function indexRoutePatterns(geojson) {
            routePatternIndex = {};
            routePatternNumbersIndex = {};
            geojson.features.forEach(function (f) {
                var p = f.properties || {};
                // Candidate property names that might contain route number/identifier in the dataset.
                var candidates = [
                    p.route_no, p.ROUTE_NO, p.RouteNo, p.route, p.route_id, p.routeid,
                    p.route_number, p.Route, p.RouteID, p.RTENO, p.ROUTE
                ];
                // pattern name (human-readable) - kept for backward compatibility if needed
                var patternName = extractPatternNameFromProps(p);
                // numeric identifiers
                var patternNums = extractPatternNumbersFromProps(p);

                // flatten and normalize
                candidates.forEach(function (c) {
                    if (c === undefined || c === null) return;
                    var k = normalizeKey(c);
                    if (!k) return;
                    if (!routePatternIndex[k]) routePatternIndex[k] = [];
                    routePatternIndex[k].push(f);

                    if (patternNums && patternNums.length) {
                        if (!routePatternNumbersIndex[k]) routePatternNumbersIndex[k] = [];
                        routePatternNumbersIndex[k] = routePatternNumbersIndex[k].concat(patternNums);
                    }
                });

                // also index by any "route-like" value found elsewhere in properties (robust fallback)
                Object.keys(p).forEach(function (key) {
                    var val = p[key];
                    if (!val) return;
                    var k = normalizeKey(val);
                    // if value looks like a short number (1-6 chars) or includes digits and letters, index it.
                    if (k && k.length <= 6) {
                        if (!routePatternIndex[k]) routePatternIndex[k] = [];
                        routePatternIndex[k].push(f);

                        if (patternNums && patternNums.length) {
                            if (!routePatternNumbersIndex[k]) routePatternNumbersIndex[k] = [];
                            routePatternNumbersIndex[k] = routePatternNumbersIndex[k].concat(patternNums);
                        } else {
                            // also try to use the normalized key itself if it's numeric
                            var m = k.match(/^\d{1,6}$/);
                            if (m) {
                                if (!routePatternNumbersIndex[k]) routePatternNumbersIndex[k] = [];
                                routePatternNumbersIndex[k].push(k);
                            }
                        }
                    }
                });
            });
            // reduce duplicates in each bucket
            Object.keys(routePatternIndex).forEach(function (k) {
                routePatternIndex[k] = routePatternIndex[k].filter((v, idx, arr) => arr.indexOf(v) === idx);
            });
            Object.keys(routePatternNumbersIndex).forEach(function (k) {
                routePatternNumbersIndex[k] = routePatternNumbersIndex[k].filter((v, idx, arr) => arr.indexOf(v) === idx);
            });

            // After building the index, update any existing markers so they show pattern numbers next to route name
            updateMarkersWithPatterns();
        }

        // Return unique array of pattern numbers (strings) for a GTFS route id
        function getPatternNumbersForGtfsRoute(gtfsRouteId) {
            if (!gtfsRouteId) return [];
            var keys = candidateKeysForGtfsRoute(gtfsRouteId);
            var matched = [];
            keys.forEach(function (k) {
                if (routePatternNumbersIndex[k]) matched = matched.concat(routePatternNumbersIndex[k]);
            });
            var kfull = normalizeKey(gtfsRouteId);
            if (routePatternNumbersIndex[kfull]) matched = matched.concat(routePatternNumbersIndex[kfull]);
            // dedupe and keep as strings
            matched = matched.map(String).filter((v, idx, arr) => arr.indexOf(v) === idx);
            return matched;
        }

        // Update existing markers' desc and tooltip to include pattern numbers (if any)
        function updateMarkersWithPatterns() {
            Object.keys(markers).forEach(function (mid) {
                var m = markers[mid];
                if (!m) return;
                var rid = m.route_id;
                if (!rid) return;
                var r = routes[rid];
                var sid = safeId(m._entityId || mid);
                var descBase = `<b>${(m.options && m.options.desc) ? (m.options.desc.split('<br>')[0] || '') : ('id ' + mid)}</b><br>`;
                // if route info present, rebuild desc to include pattern numbers
                if (r) {
                    var patternNums = getPatternNumbersForGtfsRoute(rid);
                    var patternText = patternNums && patternNums.length ? ` (${patternNums.join(' / ')})` : '';
                    descBase = `<b>${(m.options && m.options.desc) ? (m.options.desc.split('<br>')[0] || '') : ('id ' + mid)}</b><br>`;
                    descBase += `Agency: ${r.agency_id}<br>Route: ${r.route_long_name}${patternText}<br>Headsign: <div id="headsign-${sid}"></div>`;
                    m.options.desc = descBase;
                }
                // rebuild tooltip HTML (preserve speed/occupancy etc)
                var speed = m.speed || 0;
                var occ = m.occupancy_status;
                var bike = m.bikes_allowed;
                var acc = m.accessibility;
                var license = "";
                try {
                    var t = m.getTooltip && m.getTooltip();
                    if (t && t.getContent) {
                        var c = t.getContent();
                        var mlic = String(c).match(/License plate:\s*([^<\n]+)/i);
                        if (mlic && mlic[1]) license = mlic[1].trim();
                    }
                } catch (e) {}
                var tooltipHtml = `${m.options.desc}
                    Speed: ${speed} km/h<br>
                    Occupancy: ${occupancy[occ] || ""}<br>
                    License plate: ${license}<br>
                    Bike Enabled: <span id="bike_allowed-${sid}">${bikeText(bike)}</span><br>
                    Accessibility: <span id="accessibility-${sid}">${accessibilityText(acc)}</span>
                `;
                try {
                    m.unbindTooltip && m.unbindTooltip();
                    m.bindTooltip && m.bindTooltip(tooltipHtml);
                } catch (e) {
                    // ignore
                }
            });
        }

        // Show route pattern(s) matching a GTFS route id
        function showRoutePatternForGtfsRoute(gtfsRouteId, options) {
            patternLayerGroup.clearLayers();
            if (!routePatternIndex || Object.keys(routePatternIndex).length === 0) {
                $("#status").text("Route pattern data not loaded.");
                return;
            }
            var keys = candidateKeysForGtfsRoute(gtfsRouteId);
            var matched = [];
            keys.forEach(function (k) {
                if (routePatternIndex[k]) matched = matched.concat(routePatternIndex[k]);
            });
            // As a last resort try direct normalized full id
            var kfull = normalizeKey(gtfsRouteId);
            if (routePatternIndex[kfull]) matched = matched.concat(routePatternIndex[kfull]);

            // unique
            matched = matched.filter((v, idx, arr) => arr.indexOf(v) === idx);

            if (matched.length === 0) {
                $("#status").text(`No pattern found for ${gtfsRouteId}`);
                return;
            }

            // style each matched feature and add to group
            matched.forEach(function (f) {
                var style = {
                    color: options && options.color ? options.color : '#3388ff',
                    weight: 5,
                    opacity: 0.9
                };
                var gj = L.geoJSON(f, { style: style });
                patternLayerGroup.addLayer(gj);
            });

            // fit map to the pattern bounds (if desired)
            try {
                var b = patternLayerGroup.getBounds();
                if (b && b.isValid()) {
                    map.fitBounds(b.pad(0.25));
                }
            } catch (e) {
                // ignore
            }
            $("#status").text(`Showing ${matched.length} pattern(s) for ${gtfsRouteId}`);
        }

        // fetch patterns now
        fetchRoutePatterns();

        // === existing GTFS / realtime code ===

        map.spin(true);
        fetch('https://api.at.govt.nz/gtfs/v3/routes', {
            method: 'GET',
            headers: {
                'Cache-Control': 'no-cache',
                'Ocp-Apim-Subscription-Key': 'b122c467e7e145b7bfcd6d854d09b01b',
            }
        })
        .then(response => response.json())
        .then(response => {
            map.spin(false);
            if (response.message) {
                console.error(response);
                $("#status").text(`Error getting routes: ${response.message}`);
            } else {
                for (var r of response.data) {
                    if (r.attributes.route_type == 712) r.attributes.route_type = 3;
                    routes[r.id] = r.attributes;
                }
            }
            loop();
        })
        .catch(err => {
            map.spin(false);
            console.error(err);
            $("#status").text("Error loading routes.");
        });

        function loop() {
            if (hasLoaded && !document.hasFocus()) {
                console.log("tab unfocused, skipping");
                return;
            }
            hasLoaded = true;

            map.spin(true);
            fetch('https://api.at.govt.nz/realtime/legacy/vehiclelocations', {
                method: 'GET',
                headers: {
                    'Cache-Control': 'no-cache',
                    'Ocp-Apim-Subscription-Key': 'b122c467e7e145b7bfcd6d854d09b01b',
                }
            })
            .then(response => response.json())
            .then(data => {
                map.spin(false);

                // data.response.entity is expected; guard if not present
                if (!data || !data.response || !Array.isArray(data.response.entity)) {
                    console.error("Unexpected vehiclelocations response", data);
                    $("#status").text("Unexpected vehicle data.");
                    return;
                }

                for (var i in data.response.entity) {
                    if (!data.response.entity.hasOwnProperty(i)) continue;
                    var ent = data.response.entity[i];
                    var id = ent.id;
                    var v = ent.vehicle; // note: this object contains vehicle (info), position, trip, occupancy_status, etc.
                    if (!v) continue;

                    var vehicleInfo = v.vehicle || {}; // label, license_plate may be here
                    var label = vehicleInfo.label || ("id " + id);
                    var desc = `<b>${label}</b><br>`;
                    var layer = layers[null];
                    var marker = markers[id];

                    // compute a safe id for DOM elements inside tooltip
                    var sid = safeId(id);

                    if (marker) {
                        // update position
                        if (v.position && typeof v.position.latitude === "number" && typeof v.position.longitude === "number") {
                            marker.setLatLng([v.position.latitude, v.position.longitude]);
                        }
                        // update description so search works
                        marker.options.desc = desc;
                    } else {
                        marker = L.circle([v.position.latitude || 0, v.position.longitude || 0], { radius: 40, desc: desc });
                        marker._entityId = id;
                        markers[id] = marker;

                        // tooltipopen fetches trip details (headsings, bike/accessibility) and updates the per-marker elements
                        marker.on("tooltipopen", function (e) {
                            var target = e.target;
                            if (!target || !target.trip) return;
                            var tripId = target.trip.trip_id;
                            if (!tripId) return;

                            fetch('https://api.at.govt.nz/gtfs/v3/trips/' + tripId, {
                                method: 'GET',
                                headers: {
                                    'Cache-Control': 'no-cache',
                                    'Ocp-Apim-Subscription-Key': 'b122c467e7e145b7bfcd6d854d09b01b',
                                }
                            })
                            .then(resp => resp.json())
                            .then(respJson => {
                                if (respJson.message) {
                                    console.error(respJson.message);
                                    $("#status").text(`Error getting trip: ${respJson.message}`);
                                } else if (respJson.data && respJson.data.attributes) {
                                    var attrs = respJson.data.attributes;
                                    var eid = safeId(target._entityId);
                                    $("#headsign-" + eid).text(attrs.trip_headsign || "");
                                    var bikeVal = attrs.bike_allowed ?? attrs.bikes_allowed ?? attrs.bikes_allowed;
                                    $("#bike_allowed-" + eid).text(bikeText(bikeVal));
                                    var accVal = attrs.wheelchair_accessible ?? attrs.accessibility ?? attrs.wheelchair_access;
                                    $("#accessibility-" + eid).text(accessibilityText(accVal));
                                }
                            })
                            .catch(err => console.error(err));
                        });

                        // when marker is clicked show the route pattern (if available)
                        marker.on('click', function (e) {
                            if (!showPatternOnClick) return;
                            var mrk = e.target;
                            var rid = mrk.route_id || (mrk.trip && mrk.trip.route_id) || mrk.route_id_override;
                            if (rid) {
                                showRoutePatternForGtfsRoute(rid, { color: stringToColour(mrk.route_long_name || rid) });
                            } else {
                                $("#status").text("No route id for this vehicle.");
                            }
                        });
                    }

                    // populate route/trip-derived info
                    if (v.trip) {
                        var r = routes[v.trip.route_id];
                        marker.trip = v.trip;
                        marker.route_id = v.trip.route_id; // store route id for pattern lookup
                        if (r) {
                            // compute pattern numbers and append in brackets after the route long name
                            var patternNums = getPatternNumbersForGtfsRoute(v.trip.route_id);
                            var patternText = patternNums && patternNums.length ? ` (${patternNums.join(' / ')})` : '';
                            desc += `Agency: ${r.agency_id}<br>Route: ${r.route_long_name}${patternText}<br>Headsign: <div id="headsign-${sid}"></div>`;
                            marker.options.desc = desc;
                            marker.route_long_name = r.route_long_name;
                            marker.route_type = r.route_type;
                            layer = layers[r.route_type] || layers[null];
                        } else {
                            layer = layers[null];
                        }
                    }

                    marker.addTo(layer);
                    marker.speed = Math.round((v.position && v.position.speed) ? v.position.speed : 0);

                    // Read bike allowed from multiple possible locations (vehicle-level, v-level, trip-level, attributes)
                    var bikeAllowed =
                        (v.bike_allowed ?? v.bikes_allowed) ??
                        (v.vehicle && (v.vehicle.bike_allowed ?? v.vehicle.bikes_allowed)) ??
                        (v.trip && (v.trip.bike_allowed ?? (v.trip.attributes && (v.trip.attributes.bike_allowed ?? v.trip.attributes.bikes_allowed))));

                    // Read wheelchair/accessibility from multiple possible locations
                    var accessibility =
                        (v.wheelchair_accessible ?? v.accessibility) ??
                        (v.vehicle && (v.vehicle.wheelchair_accessible ?? v.vehicle.accessibility)) ??
                        (v.trip && (v.trip.wheelchair_accessible ?? (v.trip.attributes && (v.trip.attributes.wheelchair_accessible ?? v.trip.attributes.accessibility ?? v.trip.attributes.wheelchair_access))));

                    marker.bikes_allowed = bikeAllowed;
                    marker.accessibility = accessibility;

                    // Bind tooltip with unique element ids per marker to allow updates when trip fetch returns
                    var tooltipHtml = `${desc}
                        Speed: ${marker.speed} km/h<br>
                        Occupancy: ${occupancy[v.occupancy_status] || ""}<br>
                        License plate: ${vehicleInfo.license_plate || ""}<br>
                        Bike Enabled: <span id="bike_allowed-${sid}">${bikeText(marker.bikes_allowed)}</span><br>
                        Accessibility: <span id="accessibility-${sid}">${accessibilityText(marker.accessibility)}</span>
                    `;
                    marker.bindTooltip(tooltipHtml);

                    marker.occupancy_status = v.occupancy_status;
                    updateMarkerColour(marker);
                }
            })
            .catch(err => {
                map.spin(false);
                console.error(err);
                $("#status").text("Error loading vehicle locations.");
            });
        }
        setInterval(loop, 10000);
    </script>
</body>
</html>
