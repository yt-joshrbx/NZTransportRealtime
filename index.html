<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>NZ Transit Realtime Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <style>
    #map { height: 100vh; }
    .search-box {
      position: absolute;
      top: 10px;
      left: 50px;
      z-index: 1000;
      background: white;
      padding: 5px;
      border-radius: 5px;
    }
  </style>
</head>
<body>
<div id="map"></div>
<input type="text" id="search" class="search-box" placeholder="Search route or busâ€¦">

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
  // === API KEYS ===
  const AT_KEY = "b122c467e7e145b7bfcd6d854d09b01b";
  const METROINFO_KEY = "70bec02cbae84bbfa29b4e906a2035d4";

  // === MAP INITIALISE ===
  var map = L.map('map').setView([-41.2, 174.8], 6);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 20
  }).addTo(map);

  // === GLOBALS ===
  var regionLayers = {
    "Auckland": L.layerGroup().addTo(map),
    "Wellington": L.layerGroup().addTo(map),
    "Christchurch": L.layerGroup().addTo(map),
    "Waikato": L.layerGroup().addTo(map)
  };
  var markers = {
    "Auckland": {},
    "Wellington": {},
    "Christchurch": {},
    "Waikato": {}
  };
  var occupancy = ["unknown", "empty", "many seats", "few seats", "full"];

  // === FUNCTIONS ===
  function updateMarkerColour(marker) {
    let occ = marker.occupancy_status || 0;
    let colour = "blue";
    if (occ === 1) colour = "green";
    else if (occ === 2) colour = "orange";
    else if (occ === 3) colour = "red";
    marker.setStyle({ color: colour });
  }

  function updateSearchLayer() {
    // (not fully fleshed, placeholder for your existing search logic)
  }

  // === FETCH FUNCTIONS ===

  // Auckland
  function fetchAuckland() {
    fetch('https://api.at.govt.nz/realtime/legacy/vehiclelocations', {
      headers: { 'Ocp-Apim-Subscription-Key': AT_KEY }
    })
    .then(res => res.json())
    .then(data => {
      regionLayers["Auckland"].clearLayers();
      markers["Auckland"] = {};
      (data.response.entity || []).forEach(entity => {
        var latlng = [entity.vehicle.position.latitude, entity.vehicle.position.longitude];
        var occText = (entity.vehicle.occupancy_status || "unknown").toLowerCase();
        var occIdx = occupancy.indexOf(occText);
        var desc = `<b>${entity.vehicle.vehicle.label}</b><br>Plate: ${entity.vehicle.vehicle.license_plate}<br>Occupancy: ${entity.vehicle.occupancy_status || "unknown"}<br>Speed: ${entity.vehicle.position.speed}`;
        var marker = L.circle(latlng, { radius: 20, desc: desc });
        marker.route_long_name = entity.vehicle.trip.route_id;
        marker.occupancy_status = occIdx === -1 ? 0 : occIdx;
        marker.speed = entity.vehicle.position.speed;
        marker.route_type = 3;
        marker.bindTooltip(desc);
        updateMarkerColour(marker);
        marker.addTo(regionLayers["Auckland"]);
        markers["Auckland"][entity.vehicle.vehicle.id] = marker;
      });
      updateSearchLayer();
    });
  }

  // Wellington
  function fetchWellington() {
    fetch('https://gtfs-realtime-to-json.org/convert?url=https://api.opendata.metlink.org.nz/v1/gtfs-rt/vehicle-positions')
    .then(res => res.json())
    .then(data => {
      regionLayers["Wellington"].clearLayers();
      markers["Wellington"] = {};
      (data.entity || []).forEach(entity => {
        var latlng = [entity.vehicle.position.latitude, entity.vehicle.position.longitude];
        var occText = (entity.vehicle.occupancy_status || "unknown").toLowerCase();
        var occIdx = occupancy.indexOf(occText);
        var desc = `<b>${entity.vehicle.vehicle.label || entity.vehicle.vehicle.id}</b><br>Route: ${entity.vehicle.trip.route_id}<br>Occupancy: ${entity.vehicle.occupancy_status || "unknown"}`;
        var marker = L.circle(latlng, { radius: 20, desc: desc });
        marker.route_long_name = entity.vehicle.trip.route_id;
        marker.occupancy_status = occIdx === -1 ? 0 : occIdx;
        marker.speed = 0;
        marker.route_type = 3;
        marker.bindTooltip(desc);
        updateMarkerColour(marker);
        marker.addTo(regionLayers["Wellington"]);
        markers["Wellington"][entity.vehicle.vehicle.id] = marker;
      });
      updateSearchLayer();
    });
  }

  // Christchurch
  function fetchChristchurch() {
    fetch('https://apis.metroinfo.co.nz/rti/vehiclepositions', {
      headers: { 'Ocp-Apim-Subscription-Key': METROINFO_KEY }
    })
    .then(res => res.json())
    .then(data => {
      regionLayers["Christchurch"].clearLayers();
      markers["Christchurch"] = {};
      (data || []).forEach(entity => {
        var latlng = [entity.VehicleLocation.Latitude, entity.VehicleLocation.Longitude];
        var occText = (entity.Occupancy || "unknown").toLowerCase();
        var occIdx = occupancy.indexOf(occText);
        var desc = `<b>${entity.VehicleRef}</b><br>Route: ${entity.PublishedLineName}<br>To: ${entity.DestinationName}<br>Occupancy: ${entity.Occupancy || "unknown"}`;
        var marker = L.circle(latlng, { radius: 20, desc: desc });
        marker.route_long_name = entity.PublishedLineName;
        marker.occupancy_status = occIdx === -1 ? 0 : occIdx;
        marker.speed = 0;
        marker.route_type = 3;
        marker.bindTooltip(desc);
        updateMarkerColour(marker);
        marker.addTo(regionLayers["Christchurch"]);
        markers["Christchurch"][entity.VehicleRef] = marker;
      });
      updateSearchLayer();
    });
  }

  // Waikato
  function fetchWaikato() {
    fetch('https://busit.github.io/realtime-demo.json')
    .then(res => res.json())
    .then(data => {
      regionLayers["Waikato"].clearLayers();
      markers["Waikato"] = {};
      (data.vehicles || []).forEach(v => {
        var latlng = [v.lat, v.lon];
        var occText = (v.occupancy || "unknown").toLowerCase();
        var occIdx = occupancy.indexOf(occText);
        var desc = `<b>${v.id}</b><br>Route: ${v.route}<br>Plate: ${v.plate}<br>Occupancy: ${v.occupancy}<br>Speed: ${v.speed}`;
        var marker = L.circle(latlng, { radius: 20, desc: desc });
        marker.route_long_name = v.route;
        marker.occupancy_status = occIdx === -1 ? 0 : occIdx;
        marker.speed = v.speed;
        marker.route_type = 3;
        marker.bindTooltip(desc);
        updateMarkerColour(marker);
        marker.addTo(regionLayers["Waikato"]);
        markers["Waikato"][v.id] = marker;
      });
      updateSearchLayer();
    });
  }

  // === LOOPING REFRESH ===
  function refreshAll() {
    fetchAuckland();
    fetchWellington();
    fetchChristchurch();
    fetchWaikato();
  }

  refreshAll();
  setInterval(refreshAll, 30000); // refresh every 30s

</script>
</body>
</html>
