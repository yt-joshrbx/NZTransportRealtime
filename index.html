<!DOCTYPE html>
<html>
<head>
    <title>NZ Transit Realtime Map</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta content="script-src 'self' https://unpkg.com https://cdnjs.cloudflare.com https://www.googletagmanager.com;">
    <link rel="shortcut icon" type="image/x-icon" href="docs/images/favicon.ico" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.5.1/dist/leaflet.css"
        integrity="sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ=="
        crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.5.1/dist/leaflet.js"
        integrity="sha512-GffPMF3RvMeYyc1LWMHtK8EbPv0iNZ8/oTtHPx9/cc2ILxQ+u905qIwdpULaqDkyBKgOaB57QTMg7ztg8Jm2Og=="
        crossorigin=""></script>
    <script src="https://unpkg.com/leaflet-providers@1.3.0/leaflet-providers.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"
        integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/spin.js/2.3.2/spin.min.js"></script>
    <script src="https://unpkg.com/leaflet-spin@1.1.0/leaflet.spin.min.js"></script>
    <script src="https://unpkg.com/leaflet-search@2.9.8/dist/leaflet-search.src.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.0.3/chroma.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-search@2.9.8/src/leaflet-search.css" />
    <style>
        body, html { width: 100%; height: 100%; margin: 0; padding: 0; }
        #map { position: absolute; width: 100%; height: 100%; left: 0; top: 0; }
        #title {
            position: absolute;
            top: 10px;
            left: 0; right: 0; margin: auto;
            z-index: 1000; width: 600px;
            text-align: center; color: white; border-radius: 5px; padding: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            font-size: 1.1rem; font-family: Arial, Helvetica, sans-serif;
            text-shadow: 2px 2px #000000; font-weight: normal;
        }
        .info {
            background-color: white; padding: 15px; color: black;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2); border-radius: 5px;
        }
    </style>
</head>
<body>
    <h1 id="title">Welcome to the New Zealand Transit Realtime Map! (Auckland, Wellington, Christchurch, Waikato)</h1>
    <div id="map"></div>
    <script>
        // Initialize map and region boundaries
        var map = L.map('map', {
            center: [-41.2, 174.7],
            zoom: 6,
            worldCopyJump: true
        });

        var positron = L.tileLayer.provider('CartoDB.Positron').addTo(map);

        var baseMaps = {
            "OSM": L.tileLayer.provider("OpenStreetMap.Mapnik"),
            "OSM Grayscale": L.tileLayer.provider("OpenStreetMap.BlackAndWhite"),
            "CartoDB Positron": positron,
            "CartoDB Dark Matter": L.tileLayer.provider("CartoDB.DarkMatter"),
            "ESRI WorldImagery": L.tileLayer.provider("Esri.WorldImagery"),
            "Google Hybrid": L.tileLayer('http://{s}.google.com/vt/lyrs=s,h&x={x}&y={y}&z={z}', {
                maxZoom: 20,
                subdomains: ['mt0', 'mt1', 'mt2', 'mt3']
            }),
            "Wikimedia": L.tileLayer.provider("Wikimedia")
        }

        map.attributionControl.addAttribution(
            "Â© <a href='https://dev-portal.at.govt.nz/'>AT</a> | " +
            "<a href='https://apidevelopers.metroinfo.co.nz/'>Metroinfo</a> | " +
            "<a href='https://opendata.metlink.org.nz/'>Metlink</a> | " +
            "<a href='https://busit.co.nz/'>Busit</a>"
        );

        // Regional layers
        var regionLayers = {
            "Auckland": L.layerGroup().addTo(map),
            "Wellington": L.layerGroup().addTo(map),
            "Christchurch": L.layerGroup().addTo(map),
            "Waikato": L.layerGroup().addTo(map),
        };

        // Overlay control
        var overlayMaps = {
            "Auckland": regionLayers["Auckland"],
            "Wellington": regionLayers["Wellington"],
            "Christchurch": regionLayers["Christchurch"],
            "Waikato": regionLayers["Waikato"]
        };

        L.control.layers(baseMaps, overlayMaps).addTo(map);

        // Unified region marker storage
        var markers = {
            "Auckland": {},
            "Wellington": {},
            "Christchurch": {},
            "Waikato": {}
        };

        // Search control will be updated based on visible layers
        var searchLayer = L.layerGroup();
        var searchControl = L.control.search({
            layer: searchLayer,
            initial: false,
            propertyName: 'desc'
        }).addTo(map);

        // Legend & coloring
        var legend = L.control({ position: 'bottomright' });
        legend.onAdd = function (map) {
            var div = L.DomUtil.create('div', 'info legend');
            div.innerHTML = 'Colour by: <select id="colourscheme"><option>Route</option><option>Occupancy</option><option>Speed</option></select><div id="status"></div>';
            return div;
        };
        legend.addTo(map);

        var occupancy = ["empty", "many seats available", "few seats available", "standing room only", "limited standing room", "full", "not accepting passengers"];
        var occupancyColors = ["#4575b4", "#91bfdb", "#e0f3f8", "#fee090", "#fc8d59", "#d73027", "black"];
        var speedColors = chroma.scale([chroma.hsv(270, 1, 1), chroma.hsv(180, 1, 1), chroma.hsv(90, 1, 1), chroma.hsv(0, 1, 1)]).mode("hsv").domain([0, 100]);

        function stringToColour(str) {
            var hash = 0;
            for (var i = 0; i < str.length; i++) {
                hash = str.charCodeAt(i) + ((hash << 5) - hash);
            }
            var colour = '#';
            for (var i = 0; i < 3; i++) {
                var value = (hash >> (i * 8)) & 0xFF;
                colour += ('00' + value.toString(16)).substr(-2);
            }
            return colour;
        }

        // Marker coloring function
        function updateMarkerColour(marker) {
            var color = "black";
            if (window.colourscheme == "Route") {
                if (marker.route_type == 4) {
                    color = "blue";
                } else if (marker.route_long_name) {
                    color = stringToColour(marker.route_long_name);
                }
            } else if (window.colourscheme == "Occupancy" && marker.occupancy_status !== undefined) {
                color = occupancyColors[marker.occupancy_status] || "gray";
            } else if (window.colourscheme == "Speed") {
                color = speedColors(marker.speed);
            }
            marker.setStyle({ color: color });
        }

        window.colourscheme = "Route";
        $(document).on("change", "#colourscheme", function () {
            window.colourscheme = this.value;
            location.hash = this.value;
            Object.values(markers).forEach(regionMarkers => {
                for (var i in regionMarkers) {
                    updateMarkerColour(regionMarkers[i]);
                }
            });
        });

        if (location.hash) {
            window.colourscheme = location.hash.slice(1);
            $("#colourscheme").val(window.colourscheme);
        }

        // Update search layer based on visible overlays
        function updateSearchLayer() {
            searchLayer.clearLayers();
            map.eachLayer(function (layer) {
                for (var region in regionLayers) {
                    if (layer === regionLayers[region] && map.hasLayer(layer)) {
                        Object.values(markers[region]).forEach(m => searchLayer.addLayer(m));
                    }
                }
            });
        }
        map.on('overlayadd overlayremove', updateSearchLayer);

        // Search input coloring for visible markers
        $(document).on("keyup", ".search-input", function () {
            var searchVal = this.value.toLowerCase();
            map.eachLayer(function (layer) {
                for (var region in regionLayers) {
                    if (layer === regionLayers[region] && map.hasLayer(layer)) {
                        for (var i in markers[region]) {
                            var marker = markers[region][i];
                            if (!searchVal || marker.options.desc.toLowerCase().includes(searchVal)) {
                                marker.setStyle({ opacity: 1, fillOpacity: .2 });
                            } else {
                                marker.setStyle({ opacity: 0, fillOpacity: 0 });
                            }
                        }
                    }
                }
            });
        });

        // Main data loading loop
        function fetchAuckland() {
            // Auckland Transport
            fetch('https://api.at.govt.nz/realtime/legacy/vehiclelocations', {
                method: 'GET',
                headers: {
                    'Cache-Control': 'no-cache',
                    'Ocp-Apim-Subscription-Key': 'b122c467e7e145b7bfcd6d854d09b01b',
                }
            })
            .then(response => response.json())
            .then(data => {
                regionLayers["Auckland"].clearLayers();
                markers["Auckland"] = {};
                (data.response.entity || []).forEach(function (entity) {
                    var v = entity.vehicle;
                    var latlng = [v.position.latitude, v.position.longitude];
                    var desc = `<b>${v.vehicle.label}</b><br>Speed: ${Math.round(v.position.speed)} km/h<br>Occupancy: ${occupancy[v.occupancy_status] || "unknown"}<br>Plate: ${v.vehicle.license_plate}`;
                    var marker = L.circle(latlng, { radius: 20, desc: desc });
                    marker.route_long_name = v.trip && v.trip.route_id;
                    marker.occupancy_status = v.occupancy_status;
                    marker.speed = Math.round(v.position.speed);
                    marker.route_type = null; // Set if available
                    marker.bindTooltip(desc);
                    updateMarkerColour(marker);
                    marker.addTo(regionLayers["Auckland"]);
                    markers["Auckland"][entity.id] = marker;
                });
                updateSearchLayer();
            });
        }

        function fetchWellington() {
            // Metlink Wellington (example endpoint, needs real API key and endpoint)
            fetch('https://api.opendata.metlink.org.nz/v1/gtfs-rt/vehicle-positions', {
                headers: {
                    'Accept': 'application/x-protobuf',
                    // 'Authorization': 'Bearer Qe5MJQy7QKG0wVqCR7o7SkUcVYuEzX9S18LElVe0', // If required
                }
            })
            .then(response => response.arrayBuffer())
            .then(buffer => {
                // Here you would decode GTFS-realtime protobuf. Use a library such as gtfs-realtime-bindings (not shown).
                // For demo, just clear and skip.
                regionLayers["Wellington"].clearLayers();
                markers["Wellington"] = {};
                // Add marker demo (remove in production)
                /*
                var marker = L.circle([-41.2865, 174.7762], { radius: 20, desc: "Demo Bus (Wellington)" });
                marker.route_long_name = "DemoRoute";
                marker.occupancy_status = 0;
                marker.speed = 42;
                marker.route_type = 3;
                marker.bindTooltip(marker.options.desc);
                updateMarkerColour(marker);
                marker.addTo(regionLayers["Wellington"]);
                markers["Wellington"]["demo"] = marker;
                */
                // TODO: Parse and add real markers for Metlink
                updateSearchLayer();
            });
        }

        function fetchChristchurch() {
            // Metroinfo Christchurch (example endpoint, needs real API key and endpoint)
            fetch('https://apis.metroinfo.co.nz/rti/vehiclepositions', {
                headers: {
                    // 'Ocp-Apim-Subscription-Key': '70bec02cbae84bbfa29b4e906a2035d4',
                }
            })
            .then(response => response.json())
            .then(data => {
                regionLayers["Christchurch"].clearLayers();
                markers["Christchurch"] = {};
                // TODO: Parse and add real markers for Metroinfo
                updateSearchLayer();
            });
        }

        function fetchWaikato() {
            // Busit Waikato (may be static demo or real endpoint)
            fetch('https://busit.github.io/realtime-demo.json')
            .then(response => response.json())
            .then(data => {
                regionLayers["Waikato"].clearLayers();
                markers["Waikato"] = {};
                // TODO: Parse and add real markers for Busit
                updateSearchLayer();
            });
        }

        // Main update loop
        function updateAllRegions() {
            fetchAuckland();
            fetchWellington();
            fetchChristchurch();
            fetchWaikato();
        }

        setInterval(updateAllRegions, 10000);
        updateAllRegions();

    </script>
</body>
</html>
