<!DOCTYPE html>
<html>
<head>
    <title>AT Transit Realtime</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta content="script-src 'self' https://unpkg.com https://cdnjs.cloudflare.com https://www.googletagmanager.com;">
    <link rel="shortcut icon" type="image/x-icon" href="docs/images/favicon.ico" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.5.1/dist/leaflet.css"
        integrity="sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ=="
        crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.5.1/dist/leaflet.js"
        integrity="sha512-GffPMF3RvMeYyc1LWMHtK8EbPv0iNZ8/oTtHPx9/cc2ILxQ+u905qIwdpULaqDkyBKgOaB57QTMg7ztg8Jm2Og=="
        crossorigin=""></script>
    <script src="https://unpkg.com/leaflet-providers@1.3.0/leaflet-providers.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"
        integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/spin.js/2.3.2/spin.min.js"></script>
    <script src="https://unpkg.com/leaflet-spin@1.1.0/leaflet.spin.min.js"></script>
    <script src="https://unpkg.com/leaflet-search@2.9.8/dist/leaflet-search.src.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.0.3/chroma.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-search@2.9.8/src/leaflet-search.css" />
    <style>
        body, html { width: 100%; height: 100%; margin: 0; padding: 0; }
        #map { position: absolute; width: 100%; height: 100%; left: 0; top: 0; }
        #title {
            position: absolute;
            top: 10px;
            left: 0; right: 0; margin: auto;
            z-index: 1000; width: 500px;
            text-align: center; color: white; border-radius: 5px; padding: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            font-size: 1rem; font-family: Arial, Helvetica, sans-serif;
            text-shadow: 2px 2px #000000; font-weight: normal;
        }
        .info {
            background-color: white; padding: 15px; color: black;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2); border-radius: 5px;
        }
        .pattern-toggle { margin-top: 8px; }
        .tooltip-body { line-height: 1.4; }
        .tooltip-body div { margin: 2px 0; }
    </style>
</head>
<body>
    <h1 id="title">Welcome to the Auckland Transport Transit Realtime Map!</h1>
    <div id="map"></div>
    <script>
        var map = L.map('map', {
            center: [-36.8862, 174.7651],
            zoom: 12,
            worldCopyJump: true
        });

        var positron = L.tileLayer.provider('CartoDB.Positron').addTo(map);

        var baseMaps = {
            "OSM": L.tileLayer.provider("OpenStreetMap.Mapnik"),
            "OSM Grayscale": L.tileLayer.provider("OpenStreetMap.BlackAndWhite"),
            "CartoDB Positron": positron,
            "CartoDB Dark Matter": L.tileLayer.provider("CartoDB.DarkMatter"),
            "ESRI WorldImagery": L.tileLayer.provider("Esri.WorldImagery"),
            "Google Hybrid": L.tileLayer('http://{s}.google.com/vt/lyrs=s,h&x={x}&y={y}&z={z}', {
                maxZoom: 20,
                subdomains: ['mt0', 'mt1', 'mt2', 'mt3']
            }),
            "Wikimedia": L.tileLayer.provider("Wikimedia")
        };

        map.attributionControl.addAttribution("Â© <a href='https://dev-portal.at.govt.nz/'>AT</a>");

        var layers = {
            2: L.layerGroup().addTo(map),
            3: L.layerGroup().addTo(map),
            4: L.layerGroup().addTo(map),
            null: L.layerGroup().addTo(map)
        };

        var search = L.control.search({
            layer: L.layerGroup([layers[2], layers[3], layers[4], layers[null]]),
            initial: false,
            propertyName: 'desc'
        });
        map.addControl(search);

        // Use event delegation for .search-input which is dynamically inserted by Leaflet Search
        $(document).on("keyup", ".search-input", function () {
            var searchVal = this.value.toLowerCase();
            for (var i in markers) {
                if (!markers.hasOwnProperty(i)) continue;
                var marker = markers[i];
                if (!searchVal || (marker.options.desc && marker.options.desc.toLowerCase().includes(searchVal))) {
                    marker.setStyle({ opacity: 1, fillOpacity: .2 });
                } else {
                    marker.setStyle({ opacity: 0, fillOpacity: 0 });
                }
            }
        });

        var overlayMaps = {
            "AT Buses": layers[3],
            "AT Trains": layers[2],
            "AT Ferries": layers[4],
            "Out of Service": layers[null]
        };

        L.control.layers(baseMaps, overlayMaps).addTo(map);

        var legend = L.control({ position: 'bottomright' });
        legend.onAdd = function (map) {
            var div = L.DomUtil.create('div', 'info legend');
            div.innerHTML = 'Colour by: <select id="colourscheme"><option>Route</option><option>Occupancy</option><option>Speed</option></select><div id="status"></div>';
            return div;
        };
        legend.addTo(map);

        $(document).on("change", "#colourscheme", function () {
            window.colourscheme = this.value;
            location.hash = this.value;
            for (var i in markers) {
                if (!markers.hasOwnProperty(i)) continue;
                updateMarkerColour(markers[i]);
            }
        });

        window.colourscheme = "Route";
        if (location.hash) {
            window.colourscheme = location.hash.slice(1);
            $("#colourscheme").val(window.colourscheme);
        }

        function stringToColour(str) {
            var hash = 0;
            for (var i = 0; i < str.length; i++) {
                hash = str.charCodeAt(i) + ((hash << 5) - hash);
            }
            var colour = '#';
            for (var i = 0; i < 3; i++) {
                var value = (hash >> (i * 8)) & 0xFF;
                colour += ('00' + value.toString(16)).substr(-2);
            }
            return colour;
        }

        function updateMarkerColour(marker) {
            var color = "black";
            if (window.colourscheme == "Route") {
                if (marker.route_type == 4) {
                    color = "blue";
                } else if (marker.route_long_name) {
                    color = stringToColour(marker.route_long_name);
                }
            } else if (window.colourscheme == "Occupancy" && marker.occupancy_status !== undefined) {
                color = occupancyColors[marker.occupancy_status];
            } else if (window.colourscheme == "Speed") {
                color = speedColors(marker.speed);
            }
            marker.setStyle({ color: color });
        }

        var markers = {};
        var occupancy = ["empty", "many seats available", "few seats available", "standing room only", "limited standing room", "full", "not accepting passengers"];
        var occupancyColors = ["#4575b4", "#91bfdb", "#e0f3f8", "#fee090", "#fc8d59", "#d73027", "black"];
        var speedColors = chroma.scale([chroma.hsv(270, 1, 1), chroma.hsv(180, 1, 1), chroma.hsv(90, 1, 1), chroma.hsv(0, 1, 1)]).mode("hsv").domain([0, 100]);

        var hasLoaded = false;
        var routes = {};

        // Helper: safe id for building per-marker DOM ids inside tooltip
        function safeId(input) {
            if (input === null || input === undefined) return "id";
            return String(input).replace(/[^a-zA-Z0-9_\-]/g, "_");
        }

        // Display helper text for bike_allowed / bikes_allowed
        function bikeText(val) {
            // GTFS: 0 = unknown, 1 = allowed, 2 = not allowed
            if (val === null || val === undefined) return "Unknown";
            var n = parseInt(val, 10);
            if (isNaN(n)) return String(val);
            if (n === 1) return "Bikes Allowed";
            if (n === 2) return "Bikes Not Allowed";
            return "Unknown";
        }

        // Display helper for wheelchair/accessibility
        function accessibilityText(val) {
            // GTFS: 0 = unknown, 1 = accessible, 2 = not accessible
            if (val === null || val === undefined) return "Unknown";
            var n = parseInt(val, 10);
            if (isNaN(n)) return String(val);
            if (n === 1) return "Accessible";
            if (n === 2) return "Not Accessible";
            return "Unknown";
        }

        // === Route pattern (ArcGIS) support ===
        var routePatternsGeo = null;              // full GeoJSON
        var routePatternIndex = {};               // normalizedKey -> array of features
        var routePatternNumbersIndex = {};        // normalizedKey -> array of numeric pattern identifiers (strings)
        var routePatternNamesIndex = {};
        var patternLayerGroup = L.layerGroup().addTo(map);
        var showPatternOnClick = true;

        function normalizeKey(s) {
            if (s === null || s === undefined) return "";
            return String(s).toLowerCase().trim();
        }

        function candidateKeysForGtfsRoute(gtfsRouteId) {
            if (!gtfsRouteId) return [];
            var keys = [];
            var raw = normalizeKey(gtfsRouteId);
            keys.push(raw);
            // split on non-alphanumeric to get base number (e.g., "101-202" -> "101")
            var first = raw.split(/[^0-9a-z]+/)[0];
            if (first && keys.indexOf(first) === -1) keys.push(first);
            return keys;
        }

        // extract numeric pattern ids (digits) from properties
        function extractPatternNumbersFromProps(p) {
            if (!p) return [];
            var nums = [];
            Object.keys(p).forEach(function (key) {
                var val = p[key];
                if (val === null || val === undefined) return;
                var s = String(val);
                var lname = key.toLowerCase();
                if (lname.includes('pattern') || lname.includes('patno') || lname.includes('pat_id') || lname.includes('rteno') || lname.includes('route_no') || lname.includes('routeid')) {
                    var m = s.match(/\d{1,6}/g);
                    if (m) nums = nums.concat(m);
                } else {
                    var m2 = s.match(/\d{2,6}/g);
                    if (m2) nums = nums.concat(m2);
                }
            });
            nums = nums.map(n => String(n));
            return nums.filter((v, idx, arr) => arr.indexOf(v) === idx);
        }

        function extractPatternNameFromProps(p) {
            if (!p) return null;
            var candidates = [
                p.pattern_name, p.pattern, p.PATTERN, p.Pattern, p.name, p.NAME,
                p.route_pattern, p.RoutePattern, p.DESC, p.DESCRIPTION, p.Descriptn,
                p.RouteNo, p.ROUTE_NO, p.route_no, p.Route, p.RouteName, p.ROUTE
            ];
            for (var i = 0; i < candidates.length; i++) {
                var v = candidates[i];
                if (v === undefined || v === null) continue;
                var s = String(v).trim();
                if (s.length > 0 && s.toLowerCase() !== 'null') return s;
            }
            for (var key in p) {
                if (!p.hasOwnProperty(key)) continue;
                var val = p[key];
                if (!val) continue;
                var s = String(val).trim();
                if (s.length > 0 && s.length <= 30) return s;
            }
            return null;
        }

        function indexRoutePatterns(geojson) {
            routePatternIndex = {};
            routePatternNumbersIndex = {};
            routePatternNamesIndex = {};
            geojson.features.forEach(function (f) {
                var p = f.properties || {};
                var candidates = [
                    p.route_no, p.ROUTE_NO, p.RouteNo, p.route, p.route_id, p.routeid,
                    p.route_number, p.Route, p.RouteID, p.RTENO, p.ROUTE
                ];
                var patternName = extractPatternNameFromProps(p);
                var patternNums = extractPatternNumbersFromProps(p);

                candidates.forEach(function (c) {
                    if (c === undefined || c === null) return;
                    var k = normalizeKey(c);
                    if (!k) return;
                    if (!routePatternIndex[k]) routePatternIndex[k] = [];
                    routePatternIndex[k].push(f);

                    if (patternNums && patternNums.length) {
                        if (!routePatternNumbersIndex[k]) routePatternNumbersIndex[k] = [];
                        routePatternNumbersIndex[k] = routePatternNumbersIndex[k].concat(patternNums);
                    }
                    if (patternName) {
                        if (!routePatternNamesIndex[k]) routePatternNamesIndex[k] = [];
                        routePatternNamesIndex[k].push(patternName);
                    }
                });

                Object.keys(p).forEach(function (key) {
                    var val = p[key];
                    if (!val) return;
                    var k = normalizeKey(val);
                    if (k && k.length <= 6) {
                        if (!routePatternIndex[k]) routePatternIndex[k] = [];
                        routePatternIndex[k].push(f);

                        if (patternNums && patternNums.length) {
                            if (!routePatternNumbersIndex[k]) routePatternNumbersIndex[k] = [];
                            routePatternNumbersIndex[k] = routePatternNumbersIndex[k].concat(patternNums);
                        } else {
                            var m = k.match(/^\d{1,6}$/);
                            if (m) {
                                if (!routePatternNumbersIndex[k]) routePatternNumbersIndex[k] = [];
                                routePatternNumbersIndex[k].push(k);
                            }
                        }

                        if (patternName) {
                            if (!routePatternNamesIndex[k]) routePatternNamesIndex[k] = [];
                            routePatternNamesIndex[k].push(patternName);
                        }
                    }
                });
            });

            Object.keys(routePatternIndex).forEach(function (k) {
                routePatternIndex[k] = routePatternIndex[k].filter((v, idx, arr) => arr.indexOf(v) === idx);
            });
            Object.keys(routePatternNumbersIndex).forEach(function (k) {
                routePatternNumbersIndex[k] = routePatternNumbersIndex[k].filter((v, idx, arr) => arr.indexOf(v) === idx);
            });
            Object.keys(routePatternNamesIndex).forEach(function (k) {
                routePatternNamesIndex[k] = routePatternNamesIndex[k].filter((v, idx, arr) => arr.indexOf(v) === idx);
            });

            updateMarkersWithPatterns();
        }

        function getPatternNumbersForGtfsRoute(gtfsRouteId) {
            if (!gtfsRouteId) return [];
            var keys = candidateKeysForGtfsRoute(gtfsRouteId);
            var matched = [];
            keys.forEach(function (k) {
                if (routePatternNumbersIndex[k]) matched = matched.concat(routePatternNumbersIndex[k]);
            });
            var kfull = normalizeKey(gtfsRouteId);
            if (routePatternNumbersIndex[kfull]) matched = matched.concat(routePatternNumbersIndex[kfull]);
            matched = matched.map(String).filter((v, idx, arr) => arr.indexOf(v) === idx);
            return matched;
        }

        function tokens(s) {
            if (!s) return [];
            return normalizeKey(s).split(/\W+/).filter(Boolean);
        }

        function extractPatternName(feature) {
            return extractPatternNameFromProps(feature.properties || {});
        }

        // Decide if a feature's pattern name seems to match the headsign text.
        function patternMatchesHeadsign(feature, headsign) {
            if (!headsign) return true; // no headsign to match -> treat as match
            var pName = extractPatternName(feature) || "";
            var hn = normalizeKey(headsign);
            var pn = normalizeKey(pName);
            if (!pn) return false;
            if (pn.includes(hn) || hn.includes(pn)) return true;
            var tpn = tokens(pName);
            var thn = tokens(headsign);
            for (var i = 0; i < tpn.length; i++) {
                if (tpn[i].length < 3) continue;
                for (var j = 0; j < thn.length; j++) {
                    if (thn[j].length < 3) continue;
                    if (tpn[i] === thn[j]) return true;
                }
            }
            return false;
        }

        // get pattern numbers for a route filtered by headsign (returns array of numeric strings)
        function getPatternNumbersMatchingHeadsign(gtfsRouteId, headsign) {
            if (!gtfsRouteId) return [];
            var keys = candidateKeysForGtfsRoute(gtfsRouteId);
            var feats = [];
            keys.forEach(function (k) {
                if (routePatternIndex[k]) feats = feats.concat(routePatternIndex[k]);
            });
            var kfull = normalizeKey(gtfsRouteId);
            if (routePatternIndex[kfull]) feats = feats.concat(routePatternIndex[kfull]);
            feats = feats.filter((v, idx, arr) => arr.indexOf(v) === idx);
            var nums = [];
            feats.forEach(function (f) {
                if (patternMatchesHeadsign(f, headsign)) {
                    nums = nums.concat(extractPatternNumbersFromProps(f.properties || {}));
                }
            });
            nums = nums.map(String).filter((v, idx, arr) => arr.indexOf(v) === idx);
            return nums;
        }

        // Update existing markers' desc & tooltip route pattern display (pattern numbers) using headsign when available
        function updateMarkersWithPatterns() {
            Object.keys(markers).forEach(function (mid) {
                var m = markers[mid];
                if (!m) return;
                var rid = m.route_id;
                if (!rid) return;
                var r = routes[rid];
                var sid = safeId(m._entityId || mid);
                if (r) {
                    var patternNums = [];
                    if (m.headsign) {
                        patternNums = getPatternNumbersMatchingHeadsign(rid, m.headsign);
                        if (!patternNums.length) patternNums = getPatternNumbersForGtfsRoute(rid);
                    } else {
                        patternNums = getPatternNumbersForGtfsRoute(rid);
                    }
                    var patternText = patternNums && patternNums.length ? ` (${patternNums.join(' / ')})` : '';
                    var desc = `<b>${(m.options && m.options.desc) ? (m.options.desc.split('<br>')[0] || '') : ('id ' + mid)}</b><br>`;
                    desc += `Agency: ${r.agency_id}<br>Route: ${r.route_long_name}${patternText}<br>Headsign: <div id="headsign-${sid}"></div>`;
                    m.options.desc = desc;

                    // If tooltip is open for this marker, update the route & pattern span too
                    $("#routeLong-" + sid).text(r.route_long_name || "");
                    $("#routePattern-" + sid).text(patternNums && patternNums.length ? ` (${patternNums.join(' / ')})` : "");
                    $("#agency-" + sid).text(r.agency_id || "");
                }
            });
        }

        // fill tooltip DOM elements for a marker (safe to call repeatedly)
        function updateTooltipFields(marker) {
            try {
                var sid = safeId(marker._entityId || marker.vehicle_id || '');
                // only update if tooltip elements exist in DOM (they will when tooltip is open)
                if ($("#vehicleid-" + sid).length) {
                    $("#vehicleid-" + sid).text(marker.vehicle_id || '');
                    $("#agency-" + sid).text((routes[marker.route_id] && routes[marker.route_id].agency_id) ? routes[marker.route_id].agency_id : '');
                    $("#routeLong-" + sid).text((routes[marker.route_id] && routes[marker.route_id].route_long_name) ? routes[marker.route_id].route_long_name : '');
                    // pattern numbers: prefer headsign-matching numbers if headsign available
                    var pnums = [];
                    if (marker.headsign) pnums = getPatternNumbersMatchingHeadsign(marker.route_id, marker.headsign);
                    if (!pnums.length) pnums = getPatternNumbersForGtfsRoute(marker.route_id);
                    $("#routePattern-" + sid).text(pnums && pnums.length ? ` (${pnums.join(' / ')})` : '');
                    $("#headsign-" + sid).text(marker.headsign || (marker.trip && (marker.trip.trip_headsign || '')) || '');
                    $("#speed-" + sid).text(marker.speed || 0);
                    $("#occupancy-" + sid).text(occupancy[marker.occupancy_status] || "");
                    $("#license-" + sid).text((marker.vehicleInfo && marker.vehicleInfo.license_plate) ? marker.vehicleInfo.license_plate : "");
                    $("#bike_allowed-" + sid).text(bikeText(marker.bikes_allowed));
                    $("#accessibility-" + sid).text(accessibilityText(marker.accessibility));
                }
            } catch (e) {
                console.warn("updateTooltipFields error", e);
            }
        }

        // when showing patterns, only show features that match headsign if provided
        function showRoutePatternForGtfsRoute(gtfsRouteId, options, headsign) {
            patternLayerGroup.clearLayers();
            if (!routePatternIndex || Object.keys(routePatternIndex).length === 0) {
                $("#status").text("Route pattern data not loaded.");
                return;
            }
            var keys = candidateKeysForGtfsRoute(gtfsRouteId);
            var matched = [];
            keys.forEach(function (k) {
                if (routePatternIndex[k]) matched = matched.concat(routePatternIndex[k]);
            });
            var kfull = normalizeKey(gtfsRouteId);
            if (routePatternIndex[kfull]) matched = matched.concat(routePatternIndex[kfull]);
            matched = matched.filter((v, idx, arr) => arr.indexOf(v) === idx);

            if (headsign) {
                matched = matched.filter(function (f) {
                    return patternMatchesHeadsign(f, headsign);
                });
            }

            if (matched.length === 0) {
                $("#status").text(`No pattern found for ${gtfsRouteId}` + (headsign ? ` matching "${headsign}"` : ''));
                return;
            }

            matched.forEach(function (f) {
                var style = { color: options && options.color ? options.color : '#3388ff', weight: 5, opacity: 0.9 };
                var gj = L.geoJSON(f, { style: style });
                patternLayerGroup.addLayer(gj);
            });

            try {
                var b = patternLayerGroup.getBounds();
                if (b && b.isValid()) map.fitBounds(b.pad(0.25));
            } catch (e) {}
            $("#status").text(`Showing ${matched.length} pattern(s) for ${gtfsRouteId}` + (headsign ? ` matching "${headsign}"` : ''));
        }

        // fetch patterns
        function fetchRoutePatterns() {
            var urls = [
                'https://data-atgis.opendata.arcgis.com/datasets/ATgis::bus-route.geojson',
                'https://services.arcgis.com/ZN3Gq8hGnsb8aD0T/ArcGIS/rest/services/bus_route/FeatureServer/0/query?where=1%3D1&outFields=*&f=geojson'
            ];
            (function tryNext(i) {
                if (i >= urls.length) {
                    console.warn("Could not fetch route patterns from known endpoints.");
                    return;
                }
                var url = urls[i];
                fetch(url).then(r => {
                    if (!r.ok) throw new Error('HTTP ' + r.status);
                    return r.json();
                }).then(geojson => {
                    if (!geojson || !geojson.features) throw new Error("Not GeoJSON");
                    routePatternsGeo = geojson;
                    indexRoutePatterns(geojson);
                    console.log("Loaded route pattern GeoJSON from", url);
                }).catch(err => {
                    console.warn("Failed to fetch patterns from", url, err);
                    tryNext(i + 1);
                });
            })(0);
        }

        // kick off fetch patterns
        fetchRoutePatterns();

        // === existing GTFS / realtime code ===

        map.spin(true);
        fetch('https://api.at.govt.nz/gtfs/v3/routes', {
            method: 'GET',
            headers: {
                'Cache-Control': 'no-cache',
                'Ocp-Apim-Subscription-Key': 'b122c467e7e145b7bfcd6d854d09b01b',
            }
        })
        .then(response => response.json())
        .then(response => {
            map.spin(false);
            if (response.message) {
                console.error(response);
                $("#status").text(`Error getting routes: ${response.message}`);
            } else {
                for (var r of response.data) {
                    if (r.attributes.route_type == 712) r.attributes.route_type = 3;
                    routes[r.id] = r.attributes;
                }
            }
            loop();
        })
        .catch(err => {
            map.spin(false);
            console.error(err);
            $("#status").text("Error loading routes.");
        });

        function loop() {
            if (hasLoaded && !document.hasFocus()) {
                console.log("tab unfocused, skipping");
                return;
            }
            hasLoaded = true;

            map.spin(true);
            fetch('https://api.at.govt.nz/realtime/legacy/vehiclelocations', {
                method: 'GET',
                headers: {
                    'Cache-Control': 'no-cache',
                    'Ocp-Apim-Subscription-Key': 'b122c467e7e145b7bfcd6d854d09b01b',
                }
            })
            .then(response => response.json())
            .then(data => {
                map.spin(false);

                if (!data || !data.response || !Array.isArray(data.response.entity)) {
                    console.error("Unexpected vehiclelocations response", data);
                    $("#status").text("Unexpected vehicle data.");
                    return;
                }

                for (var i in data.response.entity) {
                    if (!data.response.entity.hasOwnProperty(i)) continue;
                    var ent = data.response.entity[i];
                    var id = ent.id;
                    var v = ent.vehicle;
                    if (!v) continue;

                    var vehicleInfo = v.vehicle || {}; // may contain label, license_plate
                    var label = vehicleInfo.label || ("id " + id);
                    var desc = `<b>${label}</b><br>`;
                    var layer = layers[null];
                    var marker = markers[id];

                    var sid = safeId(id);

                    if (marker) {
                        // update position & desc
                        if (v.position && typeof v.position.latitude === "number" && typeof v.position.longitude === "number") {
                            marker.setLatLng([v.position.latitude, v.position.longitude]);
                        }
                        marker.options.desc = desc;
                        marker.vehicleInfo = vehicleInfo;
                    } else {
                        marker = L.circle([v.position.latitude || 0, v.position.longitude || 0], { radius: 40, desc: desc });
                        marker._entityId = id;
                        marker.vehicle_id = id;
                        marker.vehicleInfo = vehicleInfo;
                        markers[id] = marker;

                        // when tooltip opens we populate fields and fetch trip details if needed
                        marker.on("tooltipopen", function (e) {
                            var target = e.target;
                            var sid_local = safeId(target._entityId || target.vehicle_id || '');
                            // populate immediate known fields
                            updateTooltipFields(target);

                            if (!target.trip) return;
                            var tripId = target.trip.trip_id;
                            if (!tripId) return;

                            fetch('https://api.at.govt.nz/gtfs/v3/trips/' + tripId, {
                                method: 'GET',
                                headers: {
                                    'Cache-Control': 'no-cache',
                                    'Ocp-Apim-Subscription-Key': 'b122c467e7e145b7bfcd6d854d09b01b',
                                }
                            }).then(resp => resp.json()).then(respJson => {
                                if (respJson.message) {
                                    console.error(respJson.message);
                                    $("#status").text(`Error getting trip: ${respJson.message}`);
                                } else if (respJson.data && respJson.data.attributes) {
                                    var attrs = respJson.data.attributes;
                                    // store useful fields on marker
                                    target.headsign = attrs.trip_headsign || "";
                                    // bikes/accessibility may be in plural or singular
                                    target.bikes_allowed = attrs.bikes_allowed ?? attrs.bike_allowed ?? target.bikes_allowed;
                                    target.accessibility = attrs.wheelchair_accessible ?? attrs.accessibility ?? target.accessibility;
                                    // now update tooltip fields and patterns (uses headsign)
                                    updateTooltipFields(target);
                                    updateMarkersWithPatterns();
                                }
                            }).catch(err => console.error(err));
                        });

                        // clicking a marker will draw the specific pattern that matches headsign (if available)
                        marker.on('click', function (e) {
                            if (!showPatternOnClick) return;
                            var mrk = e.target;
                            var rid = mrk.route_id || (mrk.trip && mrk.trip.route_id) || mrk.route_id_override;
                            var headsign = mrk.headsign || (mrk.trip && (mrk.trip.trip_headsign || '')) || '';
                            if (rid) showRoutePatternForGtfsRoute(rid, { color: stringToColour(mrk.route_long_name || rid) }, headsign);
                            else $("#status").text("No route id for this vehicle.");
                        });
                    }

                    // populate route/trip-derived info
                    if (v.trip) {
                        var r = routes[v.trip.route_id];
                        marker.trip = v.trip;
                        marker.route_id = v.trip.route_id; // store for pattern lookup
                        if (r) {
                            marker.route_long_name = r.route_long_name;
                            marker.route_type = r.route_type;
                            // pattern numbers: prefer matching to headsign if already present on marker
                            var patternNums = [];
                            if (marker.headsign) {
                                patternNums = getPatternNumbersMatchingHeadsign(v.trip.route_id, marker.headsign);
                                if (!patternNums.length) patternNums = getPatternNumbersForGtfsRoute(v.trip.route_id);
                            } else {
                                patternNums = getPatternNumbersForGtfsRoute(v.trip.route_id);
                            }
                            var patternText = patternNums && patternNums.length ? ` (${patternNums.join(' / ')})` : '';
                            desc += `Agency: ${r.agency_id}<br>Route: ${r.route_long_name}${patternText}<br>Headsign: <div id="headsign-${sid}"></div>`;
                            marker.options.desc = desc;
                            layer = layers[r.route_type] || layers[null];
                        } else {
                            layer = layers[null];
                        }
                    }

                    marker.addTo(layer);
                    marker.speed = Math.round((v.position && v.position.speed) ? v.position.speed : 0);

                    // Read bike allowed from multiple possible locations (prefer plural 'bikes_allowed')
                    var bikeAllowed =
                        (v.bikes_allowed ?? v.bike_allowed) ??
                        (v.vehicle && (v.vehicle.bikes_allowed ?? v.vehicle.bike_allowed)) ??
                        (v.trip && (v.trip.bikes_allowed ?? (v.trip.attributes && (v.trip.attributes.bikes_allowed ?? v.trip.attributes.bike_allowed))));
                    // Read wheelchair/accessibility
                    var accessibility =
                        (v.wheelchair_accessible ?? v.accessibility) ??
                        (v.vehicle && (v.vehicle.wheelchair_accessible ?? v.vehicle.accessibility)) ??
                        (v.trip && (v.trip.wheelchair_accessible ?? (v.trip.attributes && (v.trip.attributes.wheelchair_accessible ?? v.trip.attributes.accessibility ?? v.trip.attributes.wheelchair_access))));

                    marker.bikes_allowed = bikeAllowed;
                    marker.accessibility = accessibility;

                    // Build tooltip HTML with per-marker element IDs so we can fill them dynamically
                    var tooltipHtml = `<div class="tooltip-body">
                        <div><strong id="vehicleid-${sid}">${id}</strong></div>
                        <div>Agency: <span id="agency-${sid}">${(routes[marker.route_id] && routes[marker.route_id].agency_id) ? routes[marker.route_id].agency_id : ''}</span></div>
                        <div>Route: <span id="routeLong-${sid}">${(routes[marker.route_id] && routes[marker.route_id].route_long_name) ? routes[marker.route_id].route_long_name : ''}</span><span id="routePattern-${sid}"></span></div>
                        <div>Headsign: <span id="headsign-${sid}">${marker.headsign || ''}</span></div>
                        <div>Speed: <span id="speed-${sid}">${marker.speed || 0}</span> km/h</div>
                        <div>Occupancy: <span id="occupancy-${sid}">${occupancy[v.occupancy_status] || ''}</span></div>
                        <div>License Plate: <span id="license-${sid}">${vehicleInfo.license_plate || ''}</span></div>
                        <div>Bike Enabled: <span id="bike_allowed-${sid}">${bikeText(marker.bikes_allowed)}</span></div>
                        <div>Accessible: <span id="accessibility-${sid}">${accessibilityText(marker.accessibility)}</span></div>
                    </div>`;

                    marker.bindTooltip(tooltipHtml);

                    // after binding, attempt to update tooltip fields if tooltip is currently open
                    updateTooltipFields(marker);

                    marker.occupancy_status = v.occupancy_status;
                    updateMarkerColour(marker);

                    // also, if tooltip is open for this marker update DOM spans live
                    var sid_check = sid;
                    if ($("#vehicleid-" + sid_check).length) {
                        updateTooltipFields(marker);
                    }
                }
            })
            .catch(err => {
                map.spin(false);
                console.error(err);
                $("#status").text("Error loading vehicle locations.");
            });
        }
        setInterval(loop, 10000);
    </script>
</body>
</html>
